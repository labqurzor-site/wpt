<!DOCTYPE html>
<title>Subresource loading with link rel="webbundle"</title>
<link rel="help" href="https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md" />
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../resources/test-helpers.js"></script>

<script>
  window.TEST_WEB_BUNDLE_ELEMENT_TYPE = 'link';
</script>
<body>
  <link id="link-web-bundle" rel="webbundle" href="../resources/wbn/subresource.wbn" resources="https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/root.js
                   https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/submodule.js" />
  <script src="resources/subresource-load-test.sub.js"></script>
  <script>
    promise_test(async () => {
      const classic_script_url = 'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/classic_script.js';
      const element = createWebBundleElement(
          '../resources/wbn/dynamic1-b1.wbn',
          [classic_script_url]);
      document.body.appendChild(element);
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from dynamic1.wbn');
      changeWebBundleUrl(element, '../resources/wbn/dynamic2-b1.wbn');
      // Loading the classic script should not reuse the previously loaded
      // script. So in this case, the script must be loaded from dynamic2-b1.wbn.
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from dynamic2.wbn');
      document.body.removeChild(element);
      // And in this case, the script must be loaded from network.
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from network');
    }, 'Dynamically loading classic script from a \'b1\' web bundle with resources attribute');

    promise_test(async () => {
      const element = createWebBundleElement(
          '../resources/wbn/dynamic1.wbn',
          [
            'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource1.js',
            'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource2.js',
            'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource4.js'
          ]);
      document.body.appendChild(element);

      const module = await import('https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource1.js');
      assert_equals(module.result, 'resource1 from dynamic1.wbn');

      changeWebBundleUrl(element, '../resources/wbn/dynamic2-b1.wbn');
      const module2 = await import('https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource2.js');
      assert_equals(module2.result, 'resource2 from dynamic2.wbn');

      // A resource not specified in the resources attribute, but in the bundle.
      const module3 = await import('https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource3.js');
      assert_equals(module3.result, 'resource3 from network');

      document.body.removeChild(element);
      const module4 = await import('https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource4.js');
      assert_equals(module4.result, 'resource4 from network');

      // Module scripts are stored to the Document's module map once loaded.
      // So import()ing the same module script will reuse the previously loaded
      // script.
      const module_second = await import('https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/resource1.js');
      assert_equals(module_second.result, 'resource1 from dynamic1.wbn');
    }, 'Dynamically adding / updating / removing the webbundle element.');

    promise_test(async () => {
      const classic_script_url = 'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/classic_script.js';
      const element = createWebBundleElement(
          '../resources/wbn/dynamic1.wbn',
          [classic_script_url]);
      document.body.appendChild(element);
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from dynamic1.wbn');
      changeWebBundleUrl(element, '../resources/wbn/dynamic2-b1.wbn');
      // Loading the classic script should not reuse the previously loaded
      // script. So in this case, the script must be loaded from dynamic2.wbn.
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from dynamic2.wbn');
      document.body.removeChild(element);
      // And in this case, the script must be loaded from network.
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from network');
    }, 'Dynamically loading classic script from web bundle');

    promise_test(async () => {
      const classic_script_url = 'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/classic_script.js';
      const scope = 'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/dynamic/';
      const element = createWebBundleElement(
          '../resources/wbn/dynamic1.wbn',
          [],
          {scopes: [scope]});
      document.body.appendChild(element);
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from dynamic1.wbn');
      changeWebBundleUrl(element, '../resources/wbn/dynamic2.wbn');
      // Loading the classic script should not reuse the previously loaded
      // script. So in this case, the script must be loaded from dynamic2.wbn.
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from dynamic2.wbn');
      // Changes the scope not to hit the classic_script.js.
      changeWebBundleScopes(element, [scope + 'dummy']);
      // And in this case, the script must be loaded from network.
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from network');
      // Adds the scope to hit the classic_script.js.
      changeWebBundleScopes(element, [scope + 'dummy', scope + 'classic_']);
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from dynamic2.wbn');
      document.body.removeChild(element);
      // And in this case, the script must be loaded from network.
      assert_equals(
        await loadScriptAndWaitReport(classic_script_url),
        'classic script from network');
    }, 'Dynamically loading classic script from web bundle with scopes');

    promise_test(async () => {
      const wbn_url = 'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/subresource.wbn?test-resources-update';
      const resource_url = 'https://{{domains[]}}:{{ports[https][0]}}/web-bundle/resources/wbn/submodule.js';
      const element = await addWebBundleElementAndWaitForLoad(wbn_url, /*resources=*/[]);
      changeWebBundleResources(element, [resource_url]);
      const resp = await fetch(resource_url, { cache: 'no-store' });
      assert_true(resp.ok);
      assert_equals(performance.getEntriesByName(wbn_url).length, 1);
      document.body.removeChild(element);
    }, 'Updating resource attribute should not reload the bundle');
  </script>
</body>
